/** \file

This file contains special DoxyGen information for the generation of the main page and other special
documentation pages. It is not a project source file.
/

/** 

\mainpage Katiana Bootloader for Arduino (version 2.1)


<br/>\section Sec_Description Overview

Katiana is a bootloader for Atmel AVR microcontrollers with built-in USB peripherals, which:

- enumerates on USB as a CDC Class device (aka virtual serial port),
- implements a subset of the AVR109 protocol, and
- is compatible with the Arduino IDE for uploading and running sketches.

Out of the box, it builds for the ATmega32U4 and fits into a 4KB bootloader section size.
It should also be compatible with other Atmel AVR MCUs.

<br />\section Sec_Why Why Another Bootloader?

Katiana is a step in the evolution of the <em>Caterina</em> bootloader
written by Dean Camera and distributed with his LUFA software library.
Caterina was modified by Arduino for use as the bootloader on some of their boards
incorporating MCUs with built-in USB hardware (such as Leonardo and LilyPad USB).
The original boot logic was rewritten by the Arduino folks, but the rest
of Caterina was little changed.

Two main issues resulted in this author turning Caterina into Katiana:

- There was no provision for system clock prescaling other than 1:1.
- The bootloader does not enumerate on USB with a serial number.

\subsection SSec_Updates Changes and Improvments

The Katiana bootloader is based on the Catiana loader distributed
with Arduino releases as late as 1.8.4 (and maybe later). 
Here's a list of the more significant changes:

<ul>
    <li>Updated to build with LUFA version 170418.
    <li>Now supports system clock prescaling (other than 1:1).
    <li>Sketches can determine the cause of an MCU reset. 
    </li>
    <li>Custom USB serial numbers may be assigned to each physical board on which the bootloader
      is installed. 
    </li>
    <li>Sketches can get USB VID/PID from bootloader instead of boards.txt file.
    </li>
    <li>Optional address validation protects against uploads which would overwrite the bootloader. <br/>
      <ul><li>Useful if BL1 lock bits are not set to protect boot sector.</li></ul>
    </li>
    <li>Communications between bootloader and sketch cannot be accidentally 
      interfered with by the sketch.
    <li>Various changes to reduce compiled flash image size.
</ul>

<br/>\section Sec_Compat Compatibility

This bootloader was specifically developed for the ATmega32U4 MCU as used on Arduino boards such as
the Leonardo and LilyPad USB. It implements Arduino-specific behaviors and supports uploads by the Arduino IDE.
It will <em>probably</em> also work with other ATmega MCUs with built-in USB peripherals and 128kB
or less of flash memory.

Katiana responds to a subset of the Atmel AVR910 command protocol sufficient to support 
uploads from the Arduino IDE (through avrdude).
Support for various subsets of AVR910 commands may be configured in the <tt>AppConfig.h</tt> file. 

\subsection SSec_Info USB Interface Configuration

The bootloader configures the MCU's USB interface as follows:

<div align=center><table>
 <tr>
  <td><b>USB Mode:</b></td>
  <td>Device</td>
 </tr>
 <tr>
  <td><b>USB Class:</b></td>
  <td>Communications Device Class (CDC)</td>
 </tr>
 <tr>
  <td><b>USB Subclass:</b></td>
  <td>Abstract Control Model (ACM)</td>
 </tr>
 <tr>
  <td><b>Relevant Standards:</b></td>
  <td>USBIF CDC Class Standard</td>
 </tr>
 <tr>
  <td><b>Supported USB Speeds:</b></td>
  <td>Full Speed Mode</td>
 </tr>
</table></div>

<div style="page-break-after: always;"></div>

<br />\section Sec_Sizes Flash Image Size

Even with all options enabled, the bootloader fits easily inside a 4-kB flash sector
(for the ATmega32U4).
Here is a typical image size as a function of enabled options this MCU:

<div align=center><table>
<tr><td><b>Option</b></td><td><b>Image Bytes</b></td></tr>
<tr><td>None</td>                   <td class="centered">2938</td></tr>
<tr><td>Block Read/Write</td>       <td class="centered">+398</td></tr>
<tr><td>Chip Erase</td>             <td class="centered">+30</td></tr>
<tr><td>Fuse Read</td>              <td class="centered">+82</td></tr>
<tr><td>Lock Bit Write</td>         <td class="centered">+26</td></tr>
<tr><td>Flash Byte Read/Write</td>  <td class="centered">+84</td></tr>
<tr><td>EEPROM Byte Read/Write</td> <td class="centered">+48</td></tr>
<tr><td>Custom USB S/N &dagger;</td> <td class="centered">+68</td></tr>
<tr><td>LED Start Flashes</td>      <td class="centered">+54</td></tr>
<tr><td>LED Data Flashes</td>       <td class="centered">+80</td></tr>
<tr><td>All</td>                    <td class="centered">3778</td></tr>
<tr><td>Maximum Limit</td>          <td class="centered">4088</td></tr>
</table></div>

&dagger; For a 20-character serial number (size depends on length of serial number).

With other MCUs your mileage may vary, especially if the flash size is greater than 64kB.

<br />\section Sec_Running Bootloader Logic

At startup, the bootloader executes a sequence of logical tests and delays as depicted in the
flowchart below.
This provides two paths by which to enter the bootloader while at the same time providing
the fastest possible sketch startup time when the bootloader is not required.

From the point of view of a sketch, the bootloader <em>interferes</em> with
reset events. In some cases, the interference is minimal and the sketch is started with 
no delay or a small delay. 
In other cases, the bootloader intercepts the reset event and provides the capability to upload a new sketch.

When AVR910 commands are being accepted, there is a timeout period.
If eight seconds elapses with no valid AVR910 commands being received, the sketch will be
started (if there is one). If there's no sketch, there is no timeout period -- the bootloader
will remain running until a sketch has been uploaded.

\subsection SSec_SketchTest Sketch Present?

When MCU flash has been erased and only the Katiana bootloader has been installed, 
memory location zero (the reset vector) will contain all ones (0xFFFF).
When any sketch is loaded, it writes a word at location zero which will never be all ones.
Examining the contents of the location in flash is therefore sufficient to determine
if a sketch is present. 

\subsection SSec_PON Power-on and Brown-out Resets

When these resets occur, and as long as there's a sketch loaded, the bootloader starts it without delay.
If there's no sketch, the bootloader begins accepting AVR910 commands until a sketch has been loaded.

\subsection SSec_WDT WDT Resets

This is one of the paths into the bootloader, 
and is the mechanism through which the Arduino IDE normally uploads new sketches. 
Arduino core libraries (linked into every sketch) purposely generate
a WDT reset to get into the bootloader when the IDE requests an upload.
The bootloader interferes with WDT reset events and this could make it more difficult for
sketches to make use of WDT resets for their own purposes. 
Startup logic is designed to minimize the effect of this interference.

The bootloader works in cooperation with the Arduino core to make WDT reset events caused
by the sketch behave as expected. By storing a prearranged value at a pre-defined location in SRAM, 
the Arduino core can signal to the bootloader that a WDT reset was caused by the core.
In this case, the bootloader can begin accepting AVR910 commands instead of starting the sketch.
The pre-defined location is SRAM is calle the <em>BootKey</em>,
and when it contains the pre-defined value the BootKey is said to be <em>active</em>.

Beginning with IDE versions 1.6, the BootKey location is <tt>(RAMEND-1)</tt>.
When a sketch is running this normally contains the return address for the <tt>main()</tt> function.
Since <tt>main()</tt> never returns this is a safe place to pass a value to the bootloader.
The bootloader has some code in its <tt>.init0</tt> section to make a copy of the BootKey,
before it is overwritten by the bootloader's own startup code.

\subsection SSec_EXT External Resets

The first path into the bootloader is not available if the sketch disables the USB hardware
(either accidentally or on purpose). A second path into the bootloader is provided 
to deal with this situation.

The bootloader will normally start the sketch after a small delay (750ms) when an external reset occurs.
However, if a second external reset occurs during the delay period the bootloader will
instead begin accepting AVR910 commands. 
This is a failsafe mechanism which allows the user to activate the bootloader if a sketch
has been loaded which renders the CDC serial port non-functional.
The user simply taps the reset button twice in less than 750ms to enter the bootloader.
They then have a couple of seconds in which to begin an upload from the IDE.

\subsection SSec_OtherResets Other Reset Events

All reset events not mentioned above cause the bootloader to begin accepting AVR910 commands
with an 8-second timeout. 
On most (or all?) MCUs, these are the JTAG and USB reset events.

\subsection SSec_SketchResets Sketch-Induced Resets

The bootloader startup logic presents yet one more possible way to get into the bootloader.
The sketch itself can do the same thing that the core does when the serial port is 
touched at 1200 baud -- activate the BootKey and then force a WDT reset.
This all looks the same to Katiana and it will dutifully run the bootloader.

\subsection SSec_IDE_Uploads Arduino IDE Upload Process

Many Arduino boards include a separate hardware component which implements the USB interface.
On these boards it is possible for the host computer (e.g. Windows or Linux) to force
a hardware reset on the Atmel MCU -- and this provides an entry into the bootloader 
to upload a new sketch. These boards typically use the Optiboot bootloader.

This is not the case with boards such as the Leonardo or 
LilyPad USB -- the USB interface is built into the Atmel MCU here. 
As a result, there is no way for the host computer to force a hardware reset on the
Atmel MCU. 
A different technique must be used to get into the bootloader for sketch uploads.

The CDC serial port exposed by the 
bootloader enumerates with a differnt USB product ID (aka PID) than does the serial port exposed by
the sketch.
The bootloader PID is set in <tt>Descriptors.c</tt> and might be <tt>0x9207</tt> for example.
The sketch PID is set in the Arduino boards.txt file and might be <tt>0x9208</tt>.
Because of this difference,
when the bootloader is active the board might appear on Windows
as the serial port <tt>COM7</tt>, but when the sketch is running the board enumerates
as <tt>COM8</tt>.
This is part of the design of the upload process and it requires that PIDs be coordinated
between the bootloader and the boards.txt file.

To get into the bootloader, the Arduino IDE (running on the host computer)
opens the CDC serial port at 1200 baud and then immediately closes it.
With these boards, all sketchs include an Arduino core file (CDC.cpp) which detects the port
being opened at 1200 baud; when it is closed the core forces a WDT reset. 
Before doing this however, it activates the BootKey so the booloader knows that an upload is desired.

The IDE then waits for the sketch serial port to disappear, and for the bootloader serial port
to appear. Once this happens it begins sending AVR910 commands to the bootloader.

<img src="../../BootLogic.png" width=481 height=751 style="padding: 16px 16px 16px 16px">

<div style="page-break-after: always;"></div>

<br />\section Sec_UsbSerial Custom USB Serial Numbers

The bootloader can be configured to enumerate on USB with a custom hardware serial number.
Without this feature (on the Windows OS at least), every time the bootloader is plugged into a different USB
port, it will get a different serial port COM number. That's rather annoying.
This doesn't happen with Arduino boards (such as the Uno) which report serial numbers.
Having the bootloader report a serial number fixes this -- the same board will always enumerate
with the same COM port number.

For the to be truly useful, the sketch must also enumerate with a serial number for the 
same reason. 
Katiana makes the bootloader's serial number available to the sketch so that it may
report a value without having to directly encode a value into every sketch.
See the API section below for more on this.

There is an appendix at the end of this document which discusses the question of
how to pick a serial number.

\subsection SSec_EnablingUsbSerials Enabling Custom USB S/Ns

To enable custom S/Ns, define the macro <tt>CUSTOM_USB_SERIAL</tt> in the <tt>AppConfig.h</tt> header file.
The actual serial number the bootloader will report needs to be placed in the file 
<tt>UsbHdwrSerial.h</tt> prior to building the bootloader, and should look someithing like this
example:

\code
//
#pragma once
#define USB_HDWR_SERIAL "12345678901234567890"
//
\endcode

This file is not supplied with the Katiana package and must be created by the user.
Technically, the serial number string could contain any Unicode characters in any language, 
but Katiana only supports ASCII characters and reports only an English language descriptor.
See the appendix for more on restrictions imposed on USB serial numbers.

To keep the board on the same COM port, the serial number would need to be
kept constant if the bootloader is ever re-flashed. It might be useful to put a physical
label on each such board with the assigned serial number for this purpose.

\subsubsection Ssec_separate_file Why a Separate File?

Some may wonder why the serial number is in a separate header file instead of being defined
in the <tt>AppConfig.h</tt> file. 
Having the separate file allows for automated tools to automatically generate new 
serial numbers without needing to edit <tt>AppConfig.h</tt> every time.

\subsection SSec_validSnChecks Serial Number Validation

Some simple restrictions on serial numbers are applied during the build process.
A check for valid ASCII charcters and loose limits on string length is about it.

As described in the appendix, it may make sense to place more tight restrictions on user-defined
USB  serial numbers.
The restrictions suggested there may be imposed by defining the macro <tt>STRICT_USB_SERIAL</tt>
in the <tt>AppConfig.h</tt> file. 
To allow unrestricted serial numbers, comment out the definition of <tt>STRICT_USB_SERIAL</tt>
in <tt>AppConfig.h</tt>.

If strict validation is enabled, the S/N must be between 12 and 126 characters long and may only 
contain upper case hexadecimal characters (0-9, A-F). 
See the appendix for more about the requirement for unique numbers.

These restrictions are enforced during the build by
a small program defined in <tt>ValidateUsbHdwrSerial.c</tt>.
This program is compiled during the build using the native C compiler (<tt>cc</tt>).
It can be easily modified to support a different set of validation rules.

<div style="page-break-after: always;"></div>

<br />\section Sec_Building Building Katiana

The distribution has been built and tested with Cygwin.

<ol>
<li>Obtain a copy of the LUFA source code; version 170418 is known to work; later versions may work as well.</li>
<li>Create a subdirectory named <tt>Katiana</tt> within the <tt>Projects</tt> directory of the LUFA source.</li>
<li>Place the files for this bootloader inside the new Katiana subdirectory.</li>
<li>Edit makefile, specifying correct sizes for flash and boot sector.</li>
<li>Edit <tt>Config/AppConfig</tt> and select desired options.</li>
<li>Normally, <tt>Config/LUFAConfig</tt> does not require any changes.</li>
<li>If desired, the bootloader's USB PID/VID can be changed in <tt>Descriptors.c</tt>. 
Beware however that changing these typically requires a custom Boards.txt file in the Arduino
installation -- that is where USB VID/PID for the sketch are specified.</li>
<li>If custom USB serial numbers are enabled, create/edit the file <tt>UsbHdwrSerial.h</tt> with the desired USB
    hardware serial number. The script <tt>NewUsbHdwrSerial.sh</tt> may be used for this purpose if desired.
<li>Edit <tt>Board/LEDs.h</tt> to match the LED assignments on your board (if any).
If all LED options are disabled in <tt>AppConfig.h</tt> this step may be skipped. </li>
<li>Run <tt>make</tt>.</li>
<li>To generate HTML content in the <tt>Documentation</tt> folder, run <tt>make doxygen</tt>.</li>
<li>On Windows, edit <tt>Katiana-Bootloader.inf</tt> and change the USB VID/PID specified there to 
match the VID/PID combinations specified in <tt>Descriptors.c</tt> and in the <tt>Boards.txt</tt> file
that will be used for building Arduino sketches. This step is <em>not</em> required if a pre-existing
Arduino VID/PID combination is being used.
</ol>

AVRDude as used by the Arduino IDE emits only AVR910 block read/write commands for upload/verification, 
so it is only necessary to enable block support when building Katiana.
Flash and EEPROM byte support are not required.

<br />\section Sec_Installation Driver Installation

After running this bootloader for the first time on a new computer, you will need to supply the .INF
file located in this bootloader project's directory as the device's driver when running under Windows.
This will enable Windows to use its inbuilt CDC drivers, negating the need for custom drivers for the
device. Other Operating Systems should automatically use their own inbuilt CDC-ACM drivers.

<div style="page-break-after: always;"></div>

<br />\section Sec_BuildSketch Building Arduino Sketches

It may be necessary to add a custom board version which specifies some extra build flags.
Try building sketches without this at first.
Sketch uploads should always work with a freshly flashed bootloader, and they will be
directed to the bootloader's COM port from the IDE.

After the first upload, the sketch will appear on a different port.
The IDE's port setting must be changed to this new port for subsequent uploads. 
If uploads to the new port are failing, try adding the custom board with build flags as shown below.
When this fails, it is usually caused by the the core (<tt>CDC.cpp</tt>) using the 
wrong address for the BootKey.

\code
<BoardName>.build.extra_flags={build.usb_flags} -DMAGIC_KEY_POS=(RAMEND-1)
\endcode

The Arduino core libraries should detect the new bootloader based on its signature
at (FLASHEND-1) and automatically use the correct location for the boot key.
If that for some reason doesn't happen, the above build flags should force the issue.

\subsection SSec_BuildCustomDesc Custom USB Descriptors

See the API section for more on how to get the sketch to use the bootloader's 
USB device descriptor.

If the custom USB serial number option is enabled in the bootloader it is possible for the sketch to 
read the bootloader's USB serial number and use it as well.
To do this, copies of <tt>USBCore.cpp</tt> and
<tt>USBAPI.h</tt> in the <tt>Arduino-Core</tt> folder of this distribution
must be copied into the Arduino cores subdirectory. You may wish to make backup copies 
of the original files before replacing them.
The core files provided in this distribution are valid for Arduino version 1.8.4 and
may need to be modified to work with future Arduino versions.

<div style="page-break-after: always;"></div>

<br />\section Sec_HostApp Host Controller Application

This bootloader is compatible with the open source application AVRDUDE, Atmel's AVRPROG, or other
applications implementing the AVR109 protocol, which is documented on the Atmel website as an application
note.

\subsection SSec_AVRDude AVRDUDE

This section is mostly for background. Arduino IDE users may skip over it to start with.

AVRDude is a free, cross-platform and open source command line programmer for Atmel and third party AVR
programmers. It is available on the the Windows platform as part of the "WinAVR" package, or on other systems
either from a build from the official source code, or in many distributions as a precompiled binary package.
This is what the Arduino IDE uses under the hood to upload sketches.

To load a new Intel HEX file directly with AVRDude, locate the temporary directory where the sketch is
built. Do not close the IDE after building as it will delete the temporary directory when closed.
On Windows this directory is typically located here:

\code
C:\Users\<username>\AppData\Local\Temp\arduino_build_<random number>
\endcode

For these examples, it is assumed that the command window is in the temporary build directory
and that the file name of the sketch is <tt>Sketch.ino</tt>

It is necessary to specify "AVR109" as the programmer, with the allocated COM port. 
On Windows platforms this will be a standard COM port name. For example:

\code
avrdude -c AVR109 -p atmega32u4 -P COM7 -U flash:w:Sketch.ino.hex
\endcode

On Linux systems, this will typically be a device file in the <tt>/dev/ttyACMx</tt> directory.
Like this:

\code
avrdude -c AVR109 -p atmega32u4 -P /dev/ttyACM7 -U flash:w:Sketch.ino.hex
\endcode

It also possible to upload both flash and EEPROM in the same operation.
Arduino IDE builds use a <tt>.eep</tt> suffix for the EEPROM hex files.
Don't specify the <tt>.eep</tt> file if there's no EEPROM data declared in the sketch;
that may cause AVRDude to generate an error.
Here's an example of uploading both flash and EEPROM for a sketch:

\code
avrdude -c AVR109 -p at90usb1287 -P COM0 -U flash:w:Sketch.ino.hex -U eeprom:w:Sketch.ino.eep
\endcode

Run AVRDude with no command line options, 
or refer to the AVRDude project documentation for additional usage instructions.

<div style="page-break-after: always;"></div>

\subsection SSec_ArduinoUploads Arduino

No additional changes should be required for uploads to work from the Arduino IDE.
It is also possible to upload both flash and EEPROM data in the same operation with
a modification to the IDE. A custom <tt>platform.txt</tt> file is required for this purpose.
Place it in a subdirectory named <tt>hardware/breadboard/avr</tt> relative to the 
sketch's parent directory.

Make a copy of the <tt>tools.avrdude</tt> section in the standard <tt>platform.txt</tt>
file and rename it -- to <tt>eepdude</tt> for example.
Then modify the arguments on the lines <tt>tools.eepdude.upload.pattern</tt>
and <tt>tools.eepdude.upload.pattern</tt>
to include this: 

<blockquote><tt>"-Ueeprom:w:{build.path}/{build.project_name}.eep:i"</tt></blockquote>

A custom board will also need to be defined in a <tt>boards.txt</tt> file which
specifies the new <tt>eepdude</tt> programmer, like this:

<blockquote><tt>[board name].upload.tool=eepdude</tt></blockquote>

The only issue with this setup is that uploading a sketch which does not define
any EEPROM data may cause avrdude to report an error.

<div style="page-break-after: always;"></div>

<br />\section Sec_API API for Sketches

Information about the bootloader is available to sketches and Arduino core libraries
at pre-defined locations in flash.
The arduino core libraries (CDC.cpp) currently use this to determine the bootloader version.
Without this, the Arduino core won't know where the BootKey is located.

The API also provides access to custom USB descriptors programmed into the bootloader.
Here's an example of macros that could be used to access Katiana's API for sketches:

\code
//

#define KATIANA_TABLE_SIZE       8
#define KATIANA_TABLE_START      (FLASHEND - KATIANA_TABLE_SIZE + 1)

#define KATIANA_SIGNATURE        (uint16_t *)(KATIANA_TABLE_START + KATIANA_TABLE_SIZE - 2)
#define KATIANA_SIGNATURE_VALUE  0xDCFB

#define KATIANA_CLASS_SIGNATURE  (uint16_t *)(KATIANA_TABLE_START + KATIANA_TABLE_SIZE - 4)
#define KATIANA_CDC_SIGNATURE    0xDF00

#define KATIANA_USB_SERIAL       (uint8_t *)(KATIANA_TABLE_START + KATIANA_TABLE_SIZE - 6)

#define KATIANA_USB_DESCRIPTOR   (uint8_t *)(KATIANA_TABLE_START + KATIANA_TABLE_SIZE - 8)

#define BOOTKEY                  (* (uint16_t *)(RAMEND - 1) )
#define BOOTKEY_BOOT_REQUEST     0x7777
//
\endcode

 With the exception of <tt>BOOTKEY</tt>, these addresses are in flash memory and must be accessed using
 AVR <tt>pgm_read_...()</tt> functions. For example the siganture can be read like this:

 \code
 uint16_t sig = pgm_read_word( BOOTLOADER_SIGNATURE );
 \endcode

 The Arduino core looks at the boot signature to determine where the BootKey is located.

 \subsection SSec_BootKey BootKey API

 The boot key is in SRAM and accessed like any other global variable. 
 Normally, accessing BootKey is only something which is done within the Arduino core (i.e. in CDC.cpp).
 However, if a sketch wishes to force a reset into the bootloader, it can activate the BootKey
 and then force a WDT reset. For example, 
 
 \code
 BOOTKEY = BOOTKEY_BOOT_REQUEST;
 wdt_enable(0);                   // (presumes that WDT interrupts are not enabled)
 while (1);
 \endcode

\subsection Ssec_USBdescAPI USB Descriptor API

With a modified Arduino core file (<tt>USBCore.cpp</tt>) it is possible to automatically coordinate
the sketch's USB VID, PID and serial number with the values programmed into the bootloader.

Note that as long as the VID for bootloader and sketch are different, it's okay to have them report identical S/Ns.
This solves the changing port number problem and does not require a serial number to be
specified with each sketch -- it is kept by the booloader instead.

\subsubsection SSec_CoreChanges Arduino Core Modification

This is accomplished by defining global weak functions to obtain a custom device and serial number descriptors.
A <a href="https://en.wikipedia.org/wiki/Weak_symbol"><b>"weak"</b></a>
version of this function in the core returns a default result, indicating that there are no
custom descriptors available. In this case, the core behavior is unchanged.

The sketch may override these functions, providing a copy of the descriptors from bootloader flash.
This alters the core's behavior -- causing it to enumerate on USB with the desired S/N.
Thus, the core's behavior only changes if the overridden function is defined. 
This scheme does not require any special compile time flags.

Here's an example of what the modifications to USBCore.cpp might look like
to implement this behavior. First, the weak functions that can be overridden in a sketch:

\code
//
uint8_t USB_GetCustomSerialNumber(const uint8_t **buf);
uint8_t USB_GetCustomDescriptor(const uint8_t **buf);
//
uint8_t __attribute__ ((weak)) USB_GetCustomSerialNumber(const uint8_t **buffer)
{
    if (!buffer) return 0;
    *buffer = 0;
    return 0;
}
uint8_t __attribute__ ((weak)) USB_GetCustomDescriptor(const uint8_t **buffer)
{
    if (!buffer) return 0;
    *buffer = 0;
    return 0;
}
//
\endcode

And the modified <tt>SendDescriptor()</tt> function:

\code
//
bool SendDescriptor(USBSetup& setup)
{
    ...existing code omitted...
    //
	if (USB_DEVICE_DESCRIPTOR_TYPE == t)
	{
        uint8_t freeit = USB_GetCustomDescriptor(&desc_addr);
        if (desc_addr)
        {
            ret = USB_SendControl(0, desc_addr, *desc_addr);
            if (freeit) free((void *)desc_addr);
            return ret;
        }
        else
        {
		    desc_addr = (const u8*)&USB_DeviceDescriptorIAD;
        }
	}
    //
    ...more code omitted...
		else if (setup.wValueL == ISERIAL) 
        {			
			uint8_t freeit = USB_GetCustomSerialNumber( &desc_addr );
			if (desc_addr)
			{
				ret = USB_SendControl(0, desc_addr, *desc_addr);
                if (freeit) free((void *)desc_addr);
                return ret;
			}
	    #ifdef PLUGGABLE_USB_ENABLED
			else
			{
				char name[ISERIAL_MAX_LEN];
				PluggableUSB().getShortName(name);
				return USB_SendStringDescriptor((uint8_t*)name, strlen(name), 0);
			}
	    #endif
		}
    ...remaining code omitted...
//    
\endcode

\subsubsection SSec_UsbDevDesc Custom USB Device Descriptor

<tt>KATIANA_USB_DESCRIPTOR</tt> contains the address in bootloader flash of the 
bootloader's USB device descriptor. This is useful for determining the USB PID/VID
used by the bootloader. Often, the sketch will want to use the same VID and alter
the PID (increment by one for example). 

The modified Arduino core files contain a weak function
for obtaining the sketch's device descriptor. Normally they do nothing, but can be
overridden in the sketch to fetch the descriptor from bootloader flash.
The file <tt>USB_CustomDescriptors.h</tt> in the <tt>Arduino-Sketch</tt> directory
contains an example, reporduced here.

Both this example and the serial number retrieval below use this common function:

\code
void __attribute__((noinline)) CacheDescriptor( uint8_t **sram, uint16_t progPtr )
{
    if (*sram) return;
    uint16_t prog = pgm_read_word(progPtr); // read pointer to descriptor from PROGMEM
    if (prog == 0x0000u || prog == 0xffffu) return; // not a valid pointer

    uint8_t cnt = pgm_read_byte( prog );    // 1st byte of descriptor is always length
    *sram = (uint8_t *)malloc(cnt);
    if (! *sram) return;
    uint8_t *dest = *sram;
    while (cnt--) *dest++ = pgm_read_byte( prog++ );
}
\endcode

This shows how to obtain the bootloader's device descriptor.
Notice that the Product ID is incremented by one so that the sketch
reports a different value than the bootloader.
Using this scheme, it is unfortunately still necessary to enter the correct
VID/PID values in the <tt>boards.txt</tt> file used by the Arduino IDE.

\code
uint8_t USB_GetCustomDescriptor(uint8_t **buf)
{
    if (!buf) return 0;
    *buf = 0;
    CacheDescriptor(buf, FLASHEND - 7);
    if (*buf)
    {
        // increment PID by one (or could toggle if desired).
        ((DeviceDescriptor *)buf)->idProduct += 1;
        return 1;   // non-zero indicates that caller must free memory when finished with it.
    }
    return 0;
}
\endcode

\subsubsection SSec_UsbSerialAPI Custom USB Serial Number

If the option is enabled, <tt>KATIANA_USB_SERIAL</tt> contains the address in bootloader flash
of the USB serial number string descriptor. 
That can be accessed as shown below, overriding the core's weak function.

\code
uint8_t USB_GetCustomSerialNumber(uint8_t **buf)
{
    if (!buf) return 0;
    *buf = 0;
    CacheDescriptor(buf, FLASHEND - 5);
    return (*buf) ? 1 : 0;   // non-zero indicates that caller must free memory when finished with it.
}
\endcode

It returns the same serial number as the bootloader; this is okay since the sketch
uses a different PID.

<div style="page-break-after: always;"></div>

\subsection SSec_MCUSR Recovering MCUSR

When the MCU is reset, MCUSR contains bits indicating the cause of the reset.
The bootloader clears this register which means the sketch cannot examine it to 
find the cause of the last reset. 
The bootloader provides a work-around for this problem by saving the 
initial value of MCUSR and passing it to the sketch in an MCU register (R2).

When the bootloader enumerates on USB and attempts to read AVR910 commands prior to
starting the sketch then the MSB of R2 is turned on.
This resolves the ambiguity that can occur if the reset source is an external reset
or the watchdog timer.

<div sytle="align: center"><table>
<tr><td><b>Reset Source</b></td> <td><b>R2 MSB</b></td> <td><b>Interpretation</b></td></tr>
<tr> <td>WDT</td> <td>0</td> <td>Sketch Generated</td> </tr>
<tr> <td>WDT</td> <td>1</td> <td>Arduino Upload</td> </tr>
<tr> <td>External</td> <td>0</td> <td>Normal reset</td> </tr>
<tr> <td>External</td> <td>1</td> <td>Double-tap bootloader run</td> </tr>
</table></div>

The code snippet below shows how the value in R2 can be recovered for use in an Arduino sketch.
Normally, initializtion code would destroy the value in R2, making it unavailable to the sketch.
The compiler/liner arrange for functions in the <tt>.init0</tt> section to be automatically called prior 
to any other initialization code being executed. The first of these will have access to the un-sullied value of R2.
Other than having the <tt>.init0</tt> section attribute, the function is not referenced elsewhere in the sketch.
Because of this, the function must also be declared with the <tt>used</tt>
attribute to prevent the optimizing compiler from stripping it from the linked output image.

\code
//
static volatile uint8_t bootMCUSR;
//
void
__attribute__ ((naked))                 // std call/return linkage not required
__attribute__ ((section (".init0")))    // runs before any other init code
__attribute__ ((used))                  // prevents optimizer from stripping the function
saveMCUSR(void)
{
    __asm__ __volatile__ (
	"sts %0,r2\n"
	: "=m" (bootMCUSR)
	: 
    );
}
//
void setup(void)
{
    // we can safely examine the value of bootMCUSR here.
    if (bootMCUSR & _BV(PORF)) ... etc ...
}
//
\endcode

Here's a good question: what happens if multiple functions are declared in seciton <tt>.init0</tt>?
Which one will run first?
If the function to save <tt>r2</tt> is not first, there could be problems.

\subsection SSec_Flashing LED Flashes

There are three LEDs:

- L may be set to flash a fixed number of times at about 3Hz when the bootloader begins accepting commands.
- RX flashes while programming data is being received over the CDC interface.
- TX flashes while programming data is being sent out over CDC.

The RX/TX LEDs do not flash for commands or USB traffic other than programming or verification 
commands. When they flash, they are always on for 40ms and off for 40ms.

\subsection SSec_API_MemLayout Flash Memory Map
The boot sector size is determined by the <tt>BOOTSZ</tt> fuse bits.
The makefile must be manually edited to indicate the following:

<ul>
    <li>Total amount of flash in kB</li> 
    <li>Size of boot sector programmed in BOOTSZ fuses in kB.</li> 
</ul>

If these are not accurately specified, the bootloader won't function. 

The bootloader is always located at the start of the boot section.
There may be some unused space between the end of bootloader and signature
bytes, depending on boot section size and which bootloader options are enabled.
If the bootloader is too large for the declared boot sector size, it will overlap
the signature table and the linker will fail.

<img src="../../MemoryMap.png" width=418 height=401 style="padding: 16px 16px 16px 16px" />

<div style="page-break-after: always;"></div>

\section Sec_bugfixes Changes/Bug Fixes

Changes from the previous bootloader (Arduino version of Caterina) 
and fixes for bugs are listed here.

\par Atmel data sheets are wrong about flash page size.
     More than one such document states that listed page sizes are words.
     This is <em>wrong</em>. For example, the true flash page size for the
     ATmega32U4 is 128 bytes -- not 128 words as is claimed in the data sheet.

\par SPM Operations w/Interrupts Enabled
    Caterina executes self-programming sequences with interrupts enabled.
    This is a bug and could result in failure of programming operations,
    and has been fixed.

\par Brown-Out Reset Action
    The previous design would always enter the bootloader on a brown-out reset, 
    but immediately jump to the sketch on a poer-on reset.
    This seemed inconsistent, and brown-out resets are now treated identically to
    power-on resets -- the sketch is immediately started.
    To change this back to the way it was, see the function <tt>SketchStartLogic()</tt>
    in <tt>Katiana.c</tt>.

\par Timer 1
    Timer 1 was previously run in count-up mode with overflow interrupts enabled.
    It is now run in CTC (clear on compare match) mode with compare match interrupts enabled.
    This makes it possible to achieve a relatively constant interrupt rate regardless of the
    MCU input clock frequency.

\par 32-bit Variables Removed
    Doing math with 32-bit variables is expensive. Because the AVR910 command set
    limits (word) addresses to 16 bits, Katiana does all of its address math with unsigned 16-bit variables. 
    It takes a bit more work (dealing with RAMPZ) to do this, 
    but the end result is a significant reduction in flash image size.

\par AVR910 Chip Erase Command
    Support of this command is now optional.
    
<div style="page-break-after: always;"></div>

<br />\section Sec_KnownIssues Known Issues:

\par The bootloader has only been tested on ATmega32U4 MCUs.
While this should work with other MCUs having flash sizes up to 128kB and internal USB hardware,
only the ATmega32U4 MCU has been verified to work.

\par Only block read/write has been tested.
Options for flash and EEPROM byte support and lock byte writing have not been tested at all.
They are a direct copy from the original Caterina bootloader.

<div style="page-break-after: always;"></div>

<br/>\section Sec_Options Project Options

Optional behavior and subsets of AVR910 protocol support can be configured in the 
<tt>Config/AppConfig.h</tt> file.
The contents of this file in the distribution have sufficient options enabled 
for Arduino IDE uploads to work.
These are all just simple define's except as otherwise noted.

<table>
 <tr>
  <th><b>Define Name:</b></th>
  <th><b>Location:</b></th>
  <th><b>Description:</b></th>
 </tr>
 <tr>
  <td>ENABLE_SECURITY_CHECKS</td>
  <td>AppConfig.h</td>
<td>Guards against invalid flash and EEPROM addresses.</td>
 </tr>
 <tr>
  <td>LED_DATA_FLASHES</td>
  <td>AppConfig.h</td>
  <td>Flash LEDs on receipt and transmission of data.</td>
 </tr>
 <tr>
  <td>LED_START_FLASHES</td>
  <td>AppConfig.h</td>
  <td>Number of flashes of the "L" LED at bootloader startup.</td>
 </tr>
 <tr>
  <td>ENABLE_BLOCK_SUPPORT</td>
  <td>AppConfig.h</td>
  <td>Memory block read/write support. Must be enabled for Arduino uploads.</td>
 </tr>
 <tr>
  <td>ENABLE_EEPROM_BYTE_SUPPORT</td>
  <td>AppConfig.h</td>
  <td>EEPROM memory byte read/write support.</td>
 </tr>
 <tr>
  <td>ENABLE_FLASH_BYTE_SUPPORT</td>
  <td>AppConfig.h</td>
  <td>Flash memory byte read/write support.</td>
 </tr>
 <tr>
  <td>ENABLE_FLASH_ERASE_SUPPORT</td>
  <td>AppConfig.h</td>
  <td>Enables chip erase command.</td>
 </tr>
 <tr>
  <td>ENABLE_LOCK_BYTE_WRITE_SUPPORT</td>
<td>AppConfig.h</td>
  <td>Enables writing to the lock byte.</td>
 </tr>
 <tr>
  <td>CUSTOM_USB_SERIAL</td>
  <td>AppConfig.h</td>
  <td>Bootloader will enumerate with a hardware serial number on USB.</td>
 </tr>
 <tr>
  <td>STRICT_USB_SERIAL</td>
  <td>AppConfig.h</td>
  <td>Strict tests applied to USB serial number.</td>
 </tr>
 <tr>
  <td>USB_VID</td>
  <td>AppConfig.h</td>
  <td>The Vendor ID to be enumerated.</td>
 </tr>
 <tr>
  <td>USB_PID</td>
  <td>AppConfig.h</td>
  <td>The Product ID to be enumerated.</td>
 </tr>
 </table>
 
<div style="page-break-after: always;"></div>

 \subsection SSec_HdwrConfig Hardware Configuration

 Some settings should also be checked in the makefile, and adjusted to match the hardware in which the
 bootloader will be installed.

 <table>
 <tr>
  <th><b>Define Name:</b></th>
  <th><b>Location:</b></th>
  <th><b>Description:</b></th>
 </tr>
 <tr>
  <td>MCU</td>
  <td>makefile</td>
  <td>Set this to your MCU (e.g. atmeta32u4).</td>
 </tr>
 <tr>
  <td>F_USB</td>
  <td>makefile</td>
  <td>Input clock frequency on XTAL pin(s). 
      Optional, default is F_CPU.</td>
 </tr>
 <tr>
  <td>F_CPU</td>
  <td>makefile</td>
  <td>System clock frequency in Hz (after optional prescaling).</td>
 </tr>
 <tr>
  <td>FLASH_SIZE_KB</td>
  <td>makefile</td>
  <td>Set this to the size of flash memory in your MCU.</td>
 </tr>
 <tr>
  <td>BOOT_SECTOR_SIZE_KB</td>
  <td>makefile</td>
  <td>Set this to the size of boot sector programmed inot the MCU's fuses.</td>
 </tr>
</table>

<div style="page-break-after: always;"></div>

 <br />\section Sec_Conventions Programming Conventions

 Katiana is written in C. In general, the following conventions are used:

<ul>
<li>Function names are Pascal case, like this: <tt>PascalCase</tt>.</li>
<li>Variable names are Camel case, like this: <tt>camelCase</tt>.</li>
<li>Macro names are all caps with underscores between words, like this: <tt>MACRO_NAME</tt>.</li>
<ul><li>In a few places, macros which can be used like a variable use Camel case.</li></ul>
<li>Indentation levels are four spaces and tab characters are not generally used.</li>
</ul>

\subsection SSec_lineendings Line Endings

The author edits many of the source files in VisualStudio and they may contain either
LF or CR/LF line endings. 
It is recommended to use git's <tt>autocrlf</tt> option to manage this.

<div style="page-break-after: always;"></div>

<br />\section Sec_PidVid Appendix: USB VIDs and PIDs

If this bootloader is being installed on an existing Arduino board such as Leonardo or 
LilyPad USB, it might be okay to keep the VID and PID already assigned to the board.
The board is still manufactured by the same vendor, and a serial number is simply being added.

If this is a custom board, the waters become a bit murky.
First there's the legal issues, exemplified by this comment in Arduino's <tt>Makefile</tt>
for the Caterina bootloder:

\code
#
# USB vendor ID (VID)
# reuse of this VID by others is forbidden by USB-IF
# official Arduino LLC VID
# VID = 0x2341
#
\endcode

Technically, using a VID you don't have rights to is illegal even it is 
only for personal use.
If you want your own VID along with the rights to all 65,536 associated PIDs it 
will cost you at least (US)$5000. Yeah, that works for me.
There are other alternatives available for both personal and commercial developers
which may be found by performing an internet search on "usb vid pid for development work".

That said, some people may decide to reuse the VIDs/PIDs from an existing board.
Legal issues aside, what other ramifications are there to doing this?

First of all, selecting a VID which is not currently assigned to anyone may not
work. Some operating systems may not be happy if the board enumerates with 
a Vendor ID which has not been officially assigned and published by the USB-IF.

\subsection SSec_ValidSNs Valid USB Serial Numbers

The base USB standard does not specify limitations on the S/N length or what characters
it may contain. It only requires a UTF-16 lil' endian Unicode string.
For Katiana, the serial number must be 126 characters or less and only ASCII
characters between 0x20 and 0x7E inclusive are allowed.
The makefile will apply a test for these restrictions and the build fails if the S/N is not valid.

The standard for the USB Mass Storage Class / Bulk-Only Transport (Revision 1.0, Sept 31, 1999)
is much more restrictive. 
The option <tt>STRICT_USB_SERIAL</tt> applies additional tests in keeping with that standard:

- The serial number must be at least 12 characters long.
- It must contain only upper case hexadecimal characters (0-9 and A-F).
  
This standard also requires that the 80-bit value comprised of 
VID (16-bits), PID (16-bits), and last 12 characters of S/N (effectively 48 bits) be unique.
There is no way for the build to enforce this requirement.

The bootloader stores the serial number both in flash (as an ASCII string), 
and SRAM (as a Unicode string).
Long serial numbers will consume a significant amount of both memories.
The serial number location in flash is made available to sketches.

\subsection SSec_UniqueSNs Unique USB Serial Numbers

To start with, if your are building commercial products for sale and have an 
officially assigned VID/PID combination,
concerns raised below about unique serial numbers are moot.

Consider the requirement that the equivalent 80 bits of VID-PID-S/N need to be unique.
Heck, since this <em>isn't</em> a mass storage product, the requirement may only be
that the VID-PID-and entire serial number be unique.
The worst case scenario is that lots of hobbyists would use the same VID/PID.

What are the odds that two such boards wind up with the
exact same serial number? And what would happen if they did?

In theory, duplication of serial numbers is a bad thing that should never be allowed to 
happen and all folks should have their own VID/PID numbers to avoid this. 
In the real world, for hobbyists this isn't practical.
If there do happen to be two different Arduino boards which have the exact same 
VID-PID-S/N this won't really be a problem as long as they are not plugged into the 
same USB host (i.e. PC). The bottom line is that as long as your personal use and distribution of
boards is limited in scope, this is <em>not</em> necessarily a huge problem.

\subsubsection SSec_ransomSNs Pseudo-Random Serial Numbers

If you just start assigning numbers like "000000000001", "000000000002" and so on,
chances are someone else has done this too. 
A very good way to mitigate the risks is to assign semi-random 48-bit (or longer)
serial numbers to  each unit. 
A shell script is included with the bootloader package which 
generates pseudo-random serial numbers (with lots of semi-meaningless overkill).
It gets the serial number from a cryptographic hash of some semi-random text, including:

- 16 bytes of pseudo-random values from /dev/random
- Current date and time
- Long listing of the current directory with lines randomly shuffled
- Some extra "salt"

\code
#!/bin/sh
salt='Salt of the Earth'  # change this as you please
hash=md5sum  # can change to sha256sum or other hash commands known to the shell
sum=`( od -N 16 -t x /dev/random ; date ; ls -l | shuf ; echo "$salt" ) 2>&1 | $hash`
serial=${sum:0:12}
serial=`echo $serial | tr [:lower:] [:upper:]`
echo \#pragma once >NewUsbHdwrSerial.h
echo \#define USB_HDWR_SERIAL \"$serial\" >> NewUsbHdwrSerial.h
#
\endcode

The salt can be modified by each individual to further reduce odds of serial number duplication.
If you use this or a similar technique, the odds of you having the same serial number
as anyone else are extremely small. 

The example above generates 12-character serial numbers and this should be more than adequate
for most purposes.
Longer serial numbers can be generated by taking a bigger subset of the hash 
(as many as 96 charactes with sha384),
and this will further decrease the odds of ever having a duplicate serial number.
That can done by changing the <tt>${sum:0:12}</tt> on the fourth line of the shell
script above to <tt>${sum:0:32}</tt> to get a 32-character serial number for example.

The shell script above is provided with the Katiana distribution and is named
<tt>NewUsbHdwrSerial.sh</tt>.

<div style="page-break-after: always;"></div>

 <br />\section Sec_License Appendix: Software License
 
 The original source for this bootloader was BootloaderCDC.c
 licensed as follows by Dean Camera:

<blockquote>
<p>
Copyright 2017  Dean Camera (dean [at] fourwalledcubicle [dot] com)
</p>

<p>
Permission to use, copy, modify, distribute, and sell this
software and its documentation for any purpose is hereby granted
without fee, provided that the above copyright notice appear in
all copies and that both that the copyright notice and this
permission notice and warranty disclaimer appear in supporting
documentation, and that the name of the author not be used in
advertising or publicity pertaining to distribution of the
software without specific, written prior permission.
</p>

<p>
The author disclaims all warranties with regard to this
software, including all implied warranties of merchantability
and fitness.  In no event shall the author be liable for any
special, indirect or consequential damages or any damages
whatsoever resulting from loss of use, data or profits, whether
in an action of contract, negligence or other tortious action,
arising out of or in connection with the use or performance of
this software.
</p>
</blockquote>

This heavily modified version of the original source
is licensed by aweatherguy as follows:

<blockquote>
<p>Copyright (c) 2017, aweatherguy, all rights reserved.</p>

<p>
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
Neither the name "aweatherguy" nor the
names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.
</p>

<p><tt>
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL aweatherguy BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</tt></p>
</blockquote>

*/
